{
  "comments": [
    {
      "key": {
        "uuid": "08d0953a_44b9f83d",
        "filename": "rules/src/main/java/android/support/test/rule/ActivityTestRule.java",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1040223
      },
      "writtenOn": "2016-04-29T16:03:51Z",
      "side": 1,
      "message": "add newln before this line for consistency",
      "range": {
        "startLine": 60,
        "startChar": 4,
        "endLine": 60,
        "endChar": 23
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_09e20db0",
        "filename": "rules/src/main/java/android/support/test/rule/ActivityTestRule.java",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T19:40:21Z",
      "side": 1,
      "message": "@Beta ? perhaps.\n\nI think we should consider providing interception points to most of Instrumentation\u0027s methods. If we come up with a more generic approach, we may want to change this signature / behaviour.\n\nBut I do not want to block this change on that :)",
      "range": {
        "startLine": 127,
        "startChar": 11,
        "endLine": 127,
        "endChar": 27
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08d0953a_e49fe4c2",
        "filename": "rules/src/main/java/android/support/test/rule/ActivityTestRule.java",
        "patchSetId": 1
      },
      "lineNbr": 130,
      "author": {
        "id": 1040223
      },
      "writtenOn": "2016-04-29T16:03:51Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 130,
        "startChar": 8,
        "endLine": 130,
        "endChar": 12
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_467472be",
        "filename": "runner/src/androidTest/java/android/support/test/runner/MonitoringInstrumentationTest.java",
        "patchSetId": 1
      },
      "lineNbr": 81,
      "author": {
        "id": 1052388
      },
      "writtenOn": "2016-04-29T18:04:16Z",
      "side": 1,
      "message": "nit: breaks 100 character limit, please add a newline",
      "range": {
        "startLine": 81,
        "startChar": 92,
        "endLine": 81,
        "endChar": 109
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_094b2da2",
        "filename": "runner/src/androidTest/java/android/support/test/runner/MonitoringInstrumentationTest.java",
        "patchSetId": 1
      },
      "lineNbr": 88,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T19:40:21Z",
      "side": 1,
      "message": "I do not like ignoring the exception, it could make debugging the failure case more frustrating.\n\nSuggestion, wrap your runnable in a FutureTask, keep a reference to the future task local to the method, submit the future task to runonmainsync call .get() on the future task (letting its exception kill the test if necsesary) and then do your assertions",
      "range": {
        "startLine": 88,
        "startChar": 24,
        "endLine": 88,
        "endChar": 45
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_268176a0",
        "filename": "runner/src/androidTest/java/android/support/test/runner/MonitoringInstrumentationTest.java",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1052388
      },
      "writtenOn": "2016-04-29T18:04:16Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 123,
        "startChar": 94,
        "endLine": 123,
        "endChar": 99
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08d0953a_049b00db",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 1,
      "author": {
        "id": 1040223
      },
      "writtenOn": "2016-04-29T16:03:51Z",
      "side": 1,
      "message": "license",
      "range": {
        "startLine": 1,
        "startChar": 0,
        "endLine": 1,
        "endChar": 7
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08d0953a_245f1c00",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1040223
      },
      "writtenOn": "2016-04-29T16:03:51Z",
      "side": 1,
      "message": "Since this will be the public interface devs will use please be more verbose in the comments here on what it is and how you need to use it.",
      "range": {
        "startLine": 6,
        "startChar": 3,
        "endLine": 6,
        "endChar": 90
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_66ce4e95",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T19:40:21Z",
      "side": 1,
      "message": "if its a public interface it should not be in internalutil",
      "parentUuid": "08d0953a_245f1c00",
      "range": {
        "startLine": 6,
        "startChar": 3,
        "endLine": 6,
        "endChar": 90
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_89eb9dc0",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 8,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T19:40:21Z",
      "side": 1,
      "message": "If we\u0027re going to allow test authors to replace insturmentation\u0027s newActivity logic, we should give them all the information instrumentation has, and let them choose whether to serve the request, or let the default implementation serve the request.\n\nEG:\n\ninterface InterceptingActivityFactory {\n\n  // let users decide whether they\u0027re interested in handling activity creation themselves. If returns true, create will be called, else instrumentation should call super.newActivity\n  boolean shouldIntercept(ClassLoader cl, String className, Intent intent);\n  \n  // provide your activity by implementing this method, you should never recieve a call on this method unless shouldIntercept() returned true.\n  Activity create(ClassLoader cl, String, className, Intent intent);\n  \n}\n\n/** instrumentation can assign its interceptor to this default class so we do not need to do null checks everywhere\n**/\npublic final class DefaultInterceptingActivityFactoryy implelemts ... {\n   @Override\n   shouldIntercept(...) return false;\n   create(...) throw;\n}\n\n\n/** this matches your existing logic which is baked into MonitoringInstrumentation right now **/\npublic final class PrecreatedInterceptingActivityFactory {\n   final Activity premade;\n   boolean shouldIntercept(...) premade.getClass().getName().equals(className);\n\n   create(...) checkArgument(shouldIntercept(...)); return premade;\n}",
      "range": {
        "startLine": 8,
        "startChar": 17,
        "endLine": 8,
        "endChar": 33
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "480b6d61_0c1d26ae",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 8,
      "author": {
        "id": 1102959
      },
      "writtenOn": "2016-04-29T20:49:30Z",
      "side": 1,
      "message": "This looks better. However i have a question regarding \"premade\". Any specific reason for premade rather than making it on the fly when asked. As per my current implementation, a single ActivityProvider object is supposed to be used multiple times, however each time it returns a new Activity instance and for me it makes sense to return new instance because u may not want old activity instance which has already gone through its life-cycle, to be re-used.",
      "parentUuid": "28039992_89eb9dc0",
      "range": {
        "startLine": 8,
        "startChar": 17,
        "endLine": 8,
        "endChar": 33
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_2cf277ab",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 8,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T21:05:38Z",
      "side": 1,
      "message": "when I read your code I thought you just had one instance ;) But I probably read it too quickly",
      "parentUuid": "480b6d61_0c1d26ae",
      "range": {
        "startLine": 8,
        "startChar": 17,
        "endLine": 8,
        "endChar": 33
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "88e3a549_c1038265",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 8,
      "author": {
        "id": 1102959
      },
      "writtenOn": "2016-04-30T00:25:56Z",
      "side": 1,
      "message": "I tried going this route, but during implementation I realized that using something like InterceptingActivityFactory will give unwanted control of returning ANY activity instance to a single test which is a dangerous situation, as one wrongly written test can break the whole suite. For example, consider a situation where a test accidentally returns true from shouldIntercept() which will result in incorrect Activity instance being returned from MonitoringInstrumentation#newActivity() method and it can break all the tests that will run after the culprit test.\n\nThoughts?",
      "parentUuid": "28039992_2cf277ab",
      "range": {
        "startLine": 8,
        "startChar": 17,
        "endLine": 8,
        "endChar": 33
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_da083584",
        "filename": "runner/src/main/java/android/support/test/internal/util/ActivityProvider.java",
        "patchSetId": 1
      },
      "lineNbr": 8,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-30T00:39:07Z",
      "side": 1,
      "message": "The rule implementation should always clear out the old interceptor after the test finishes.\n\nif you set the interceptor directly on the instrumentation, you\u0027re telling me you know what you\u0027re doing \u0026 signing up for consequences like that.",
      "parentUuid": "88e3a549_c1038265",
      "range": {
        "startLine": 8,
        "startChar": 17,
        "endLine": 8,
        "endChar": 33
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_09d8cd2c",
        "filename": "runner/src/main/java/android/support/test/runner/MonitoringInstrumentation.java",
        "patchSetId": 1
      },
      "lineNbr": 118,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T19:40:21Z",
      "side": 1,
      "message": "either make volatile b/c it is set on test thread, read on main thread or change your useActivityProvider(...) method to check if it is on the main thread (and if it is, do the set) or if it is not, post a future to the main thread to do the setting and block till future completes.",
      "range": {
        "startLine": 118,
        "startChar": 11,
        "endLine": 118,
        "endChar": 12
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_06a79a60",
        "filename": "runner/src/main/java/android/support/test/runner/MonitoringInstrumentation.java",
        "patchSetId": 1
      },
      "lineNbr": 609,
      "author": {
        "id": 1052388
      },
      "writtenOn": "2016-04-29T18:04:16Z",
      "side": 1,
      "message": "javadoc the delta between this and the original impl",
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08d0953a_c46d08be",
        "filename": "runner/src/main/java/android/support/test/runner/MonitoringInstrumentation.java",
        "patchSetId": 1
      },
      "lineNbr": 611,
      "author": {
        "id": 1040223
      },
      "writtenOn": "2016-04-29T16:03:51Z",
      "side": 1,
      "message": "spaces",
      "range": {
        "startLine": 611,
        "startChar": 37,
        "endLine": 611,
        "endChar": 39
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_49cec56b",
        "filename": "runner/src/main/java/android/support/test/runner/MonitoringInstrumentation.java",
        "patchSetId": 1
      },
      "lineNbr": 611,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T19:40:21Z",
      "side": 1,
      "message": "I prefer a nullobject pattern instead of null checks... see suggestion in ActivityProvider about a DefaultInterceptingActivityFactory.\n\nif (interceptor.shouldIntercept(...)) { return interceptor.create(...)); } else { super.newActivity(...); }",
      "range": {
        "startLine": 611,
        "startChar": 20,
        "endLine": 611,
        "endChar": 37
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28039992_69dbc1fe",
        "filename": "runner/src/main/java/android/support/test/runner/MonitoringInstrumentation.java",
        "patchSetId": 1
      },
      "lineNbr": 613,
      "author": {
        "id": 1018443
      },
      "writtenOn": "2016-04-29T19:40:21Z",
      "side": 1,
      "message": "BTW if we\u0027re letting user code run, log out before we call them, after we call them, catch their exceptions, log the exception out, and then propagate the exception.\n\nHighly likely the code the user gives us is untested, and if it has an issue (hanging, npe, etc) I\u0027d like to clearly point the finger to the issue in the logs",
      "range": {
        "startLine": 613,
        "startChar": 0,
        "endLine": 613,
        "endChar": 16
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08d0953a_a4720c9c",
        "filename": "runner/src/main/java/android/support/test/runner/MonitoringInstrumentation.java",
        "patchSetId": 1
      },
      "lineNbr": 626,
      "author": {
        "id": 1040223
      },
      "writtenOn": "2016-04-29T16:03:51Z",
      "side": 1,
      "message": "we don\u0027t usually use this in AOSP since we use Hungarian notation",
      "range": {
        "startLine": 626,
        "startChar": 8,
        "endLine": 626,
        "endChar": 13
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08d0953a_846830ac",
        "filename": "runner/src/main/java/android/support/test/runner/MonitoringInstrumentation.java",
        "patchSetId": 1
      },
      "lineNbr": 633,
      "author": {
        "id": 1040223
      },
      "writtenOn": "2016-04-29T16:03:51Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 633,
        "startChar": 8,
        "endLine": 633,
        "endChar": 12
      },
      "revId": "21a34e7d8b806f0ffe78218bf354f076aeb2542e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}